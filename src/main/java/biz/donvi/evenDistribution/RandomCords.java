package biz.donvi.evenDistribution;


import java.util.Random;

import static biz.donvi.evenDistribution.TransitionMatrices.ROTATIONS_0_90_180_270;
import static biz.donvi.evenDistribution.TransitionMatrices.multiplyMatrixVector;
import static java.lang.Math.*;

public class RandomCords {

    private static final Random r = new Random();

    /**
     * Generates a pseudo random number using the {@code nextGaussian()} method in {@link Math}, centers it on
     * {@code center}, divides it by {@code shrink}, and makes sure that it is between {@code 0} and {@code 1}.
     *
     * @param shrink Number to divide the initial value by (before being subject to constraints)
     * @param center Number to center the values on. Must be between 0 and 1.
     * @return A random number, as described above.
     */
    static double randomG(double shrink, double center) {
        if (center < 0 || center > 1) throw new IllegalArgumentException("Center must be between 0 and 1 inclusive.");
        double randG;
        do randG = (r.nextGaussian() / shrink + center);
        while (randG < 0 || randG >= 1);
        return randG;
    }

    /**
     * Turns a double array of length 2 into an int array of length 2. (The 2w stands for 2 wide)
     *
     * @param cordPair A pair of doubles (in an array)
     * @return A pair of ints (in an array)
     */
    static int[] asIntArray2w(double[] cordPair) {
        return new int[]{
            (int) cordPair[0],
            (int) cordPair[1]};
    }

    /**
     * Returns an int array of length 2, representing a random coordinate pair that is both inside the square
     * <pre>{@code x = radiusMax * 2 and y = radiusMax * 2 centered on (0,0)}</pre>
     * and also NOT inside the square
     * <pre>{@code x = radiusMin * 2 and y = radiusMin * 2 centered on (0,0)}</pre>
     * The points generated by this method are evenly distributed throughout the area.
     *
     * @param radiusMax The maximum that {@code |x|} or {@code |y|} will be.
     * @param radiusMin The minimum that {@code |x|} or {@code |y|} will be.
     * @return A pair of numbers, each randomly generated, that satisfy the above conditions.
     */
    public static double[] getRandXySquare(int radiusMax, int radiusMin) {
        double[] randPairAtSize = new double[]{
            random() * (radiusMax - radiusMin) + radiusMin,
            random() * (radiusMax + radiusMin) - radiusMin};
        return multiplyMatrixVector(
            ROTATIONS_0_90_180_270[(int) (random() * 4)],
            randPairAtSize);
    }

    public static double[] getRandXyRectangle(double rx, double ry) {
        return new double[]{
            random() * rx * 2 - rx,
            random() * ry * 2 - ry};
    }

    public static double[] getRandXyRectangle(double rx, double ry, double hrx, double hry, double hcx, double hcy) {
        double
            xb = hcx - hrx, xt = hcx + hrx,
            yb = hcy - hry, yt = hcy + hry,
            s0l = rx - xt, s0h = ry - yb,
            s1l = xt + rx, s1h = ry - yt,
            s2l = xb + rx, s2h = yt + ry,
            s3l = rx - xb, s3h = yb + ry;
        double[] res = {random(), random()};
        switch (weightedChoice(s0l * s0h, s1l * s1h, s2l * s2h, s3l * s3h)) {
            case 0:
                res[0] = res[0] * s0l + xt;
                res[1] = res[1] * s0h + yb;
                break;
            case 1:
                res[0] = res[0] * s1l - rx;
                res[1] = res[1] * s1h + yt;
                break;
            case 2:
                res[0] = res[0] * s2l - rx;
                res[1] = res[1] * s2h - ry;
                break;
            case 3:
                res[0] = res[0] * s3l + xb;
                res[1] = res[1] * s3h - ry;
                break;
            default: // Should never be called
                return new double[]{0, 0};
        }
        return res;
    }

    private static int weightedChoice(double... options) {
        double sum = 0;
        for (double option : options) sum += option;
        double randVal = random();
        randVal *= sum;
        for (int i = 0; i < options.length; i++)
            if (randVal < options[i]) return i;
            else randVal -= options[i];
        return -1;
    }


    /**
     * Returns an int array of length 2, representing a random coordinate pair that is both inside the square
     * <pre>{@code x = radiusMax * 2 and y = radiusMax * 2 centered on (0,0)}</pre>
     * and also NOT inside the square
     * <pre>{@code x = radiusMin * 2 and y = radiusMin * 2 centered on (0,0)}</pre>
     * The points generated by this method will <em>not</em> be random. Unlike the other method, which uses
     * evenly distributed pseudo random numbers, this receives random numbers with a Gaussian distribution,
     * keeping the points concentrated around the radius {@code r} where {@code r} is
     * {@code (radiusMax - radiusMin) * gCenter + radiusMin}. {@code gShrink} is a lazily named variable
     * that is inversely related to the size of the distribution in the valid range.
     *
     * @param radiusMax The maximum that {@code |x|} or {@code |y|} will be.
     * @param radiusMin The minimum that {@code |x|} or {@code |y|} will be.
     * @param gShrink   The number to divide the initial value by.
     *                  It will make the cluster of points more dense around the center radius.
     * @param gCenter   Where to center the points between {@code radiusMin} and {@code radiusMax},
     *                  using {@code 0} and {@code 1} respectively.
     * @return A pair of numbers, each randomly generated, that satisfy the above conditions.
     */
    public static double[] getRandXySquare(int radiusMax, int radiusMin, double gShrink, double gCenter) {
        double s0 = (double) radiusMin / (double) radiusMax;
        double s1 = 1 - s0;
        double r0 = random();
        double r1 = randomG(gShrink, gCenter);
        r1 = r1 * s0 + sqrt(r1) * s1; //This is not a perfect solution
        double[] xy = {
            s0 + s1 * r1,
            s0 * r0 + r0 * r1 * s1};
        if (random() * 2 > 1) xy[1] *= -1;
        xy = multiplyMatrixVector(ROTATIONS_0_90_180_270[(int) (random() * 4)], xy);
        xy[0] *= radiusMax;
        xy[1] *= radiusMax;
        return xy;
    }


    /**
     * Returns an int array of length 2, representing a random coordinate pair that is both
     * in a circle with the given radius radiusMax, and not in the circle with the given
     * radius radiusMin.
     * The coordinates generated are evenly distributed throughout the available area.
     *
     * @param radiusMax The maximum distance from the center of the circle that a point can be.
     * @param radiusMin The minimum distance from the center of the circle that a point can be.
     * @return A pair of numbers representing a random point inside the specific area in the circle.
     */
    public static double[] getRandXyCircle(int radiusMax, int radiusMin) {
        return getRandXyCircle(radiusMax, radiusMin, 0, 0);
    }


    /**
     * Returns an int array of length 2, representing a random coordinate pair that is both
     * in a circle with the given radius radiusMax, and not in the circle with the given
     * radius radiusMin.
     * The points generated by this method will <em>not</em> be random. Unlike the other method, which uses
     * evenly distributed pseudo random numbers, this receives random numbers with a Gaussian distribution,
     * keeping the points concentrated around the radius {@code r} where {@code r} is
     * {@code (radiusMax - radiusMin) * gCenter + radiusMin}. {@code gShrink} is a lazily named variable
     * that is inversely related to the size of the distribution in the valid range.
     *
     * @param radiusMax The maximum distance from the center of the circle that a point can be.
     * @param radiusMin The minimum distance from the center of the circle that a point can be.
     *                  It will make the cluster of points more dense around the center radius.
     * @param gCenter   Where to center the points between {@code radiusMin} and {@code radiusMax},
     *                  using {@code 0} and {@code 1} respectively.
     * @return A pair of numbers representing a random point inside the specific area in the circle.
     */
    public static double[] getRandXyCircle(int radiusMax, int radiusMin, double gShrink, double gCenter) {
        double rMin2 = pow(radiusMin, 2d);
        double r = sqrt((gShrink == 0 ? random() : randomG(gShrink, gCenter)) * (pow(radiusMax, 2d) - rMin2) + rMin2);
        double theta = 2d * PI * random();
        double x = (int) (r * cos(theta));
        double y = (int) (r * sin(theta));
        return new double[]{x, y};
    }

//    public static int[] weirdCircle(double radiusMax, double radiusMin) {
////        double r_inner = radiusMin;
////        double r_outer = radiusMax;
//        double x_inner = 200;
//        double y_inner = 200;
//
//        double rad = sqrt(pow(r_inner,2) + (pow(r_outer,2) - pow(r_inner,2)) * random());
//        double angle = random() * 2 * PI;
//        double x = rad * cos(angle);
//        double y = rad * sin(angle);
//
//        if (hypot(x - x_inner, y - y_inner) < r_inner) {
//            x = x_inner - x;
//            y = y_inner - y;
//        }
//
//
////        double[] randPairAtSize = new double[]{
////                random() * (radiusMax - radiusMin) + radiusMin,
////                random() * (radiusMax + radiusMin) - radiusMin};
////        double[] result = multiplyMatrixVector(
////                ROTATIONS_0_90_180_270[(int) (random() * 4)],
////                randPairAtSize);
////        double x = result[0];
////        double y = result[1];
////
////        if ((x - x_inner ) < radiusMin&& ( y - y_inner) < radiusMin) {
////            x = x_inner - x;
////            y = y_inner - y;
////        }
//
//
//        return new int[]{(int) x, (int) y};
//    }


}